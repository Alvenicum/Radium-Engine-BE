<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Radium Engine: Ra::Core::VariableSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
 DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
 DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
 DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="radium-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Radium Engine
   &#160;<span id="projectnumber">1.4.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classRa_1_1Core_1_1VariableSet.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRa_1_1Core_1_1VariableSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ra::Core::VariableSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Heterogeneous container storing "Variables", that maps a name (std::string) to a value (of any type T).  
 <a href="classRa_1_1Core_1_1VariableSet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VariableSet_8hpp_source.html">Core/Containers/VariableSet.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Ra::Core::VariableSet:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classRa_1_1Core_1_1VariableSet__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet_1_1DynamicVisitor.html">DynamicVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for visitors with configurable per-type callbacks. Visiting will be prepared at running time by dynamically adding visitor operators for each type one want to visit in the container. The visitor accept type based on either the added operators or an external acceptance functor which can be associated/changed at runtime. This functor is only allowed to reduce the number of visited type as only type for which a visitor operator is registered can be visited. The visitor operators should be any callable that accept to be called using f(const std::string&amp;, T&amp;[, std::any&amp;&amp;])  <a href="classRa_1_1Core_1_1VariableSet_1_1DynamicVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet_1_1DynamicVisitorBase.html">DynamicVisitorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dynamically configurable visitors Users can implement this interface to build custom visitors without any restriction. To ease visitor configuration, see class <a class="el" href="classRa_1_1Core_1_1VariableSet_1_1DynamicVisitor.html" title="Base class for visitors with configurable per-type callbacks. Visiting will be prepared at running ti...">DynamicVisitor</a>.  <a href="classRa_1_1Core_1_1VariableSet_1_1DynamicVisitorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRa_1_1Core_1_1VariableSet_1_1StaticVisitor.html">StaticVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for visitors with static supported types. Visiting will be prepared at compile time by unfolding type list and generating all the required function calls for the visit. Any class that defines the same alias for a public member "types" can be used as a visitor.  <a href="structRa_1_1Core_1_1VariableSet_1_1StaticVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRa_1_1Core_1_1VariableSet_1_1TypeList.html">TypeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP based Type list for statically typed visitors.  <a href="structRa_1_1Core_1_1VariableSet_1_1TypeList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a61f36df1dda66cf204afdec4c1e17d72"><td class="memTemplParams" colspan="2"><a id="a61f36df1dda66cf204afdec4c1e17d72"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61f36df1dda66cf204afdec4c1e17d72"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a61f36df1dda66cf204afdec4c1e17d72">VariableContainer</a> = std::map&lt; std::string, T &gt;</td></tr>
<tr class="memdesc:a61f36df1dda66cf204afdec4c1e17d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type for the mapping name-&gt;value of variables with type T. <br /></td></tr>
<tr class="separator:a61f36df1dda66cf204afdec4c1e17d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709926d7e6a4184aa22606bf182296b8"><td class="memTemplParams" colspan="2"><a id="a709926d7e6a4184aa22606bf182296b8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a709926d7e6a4184aa22606bf182296b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a709926d7e6a4184aa22606bf182296b8">Variable</a> = typename <a class="el" href="classRa_1_1Core_1_1VariableSet.html#a61f36df1dda66cf204afdec4c1e17d72">VariableContainer</a>&lt; T &gt;::value_type</td></tr>
<tr class="memdesc:a709926d7e6a4184aa22606bf182296b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable type as stored in the <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a>. <br /></td></tr>
<tr class="separator:a709926d7e6a4184aa22606bf182296b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521bf033d8d909ff180fc904988805cd"><td class="memTemplParams" colspan="2"><a id="a521bf033d8d909ff180fc904988805cd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a521bf033d8d909ff180fc904988805cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a521bf033d8d909ff180fc904988805cd">VariableType</a> = typename <a class="el" href="classRa_1_1Core_1_1VariableSet.html#a709926d7e6a4184aa22606bf182296b8">Variable</a>&lt; T &gt;::second_type</td></tr>
<tr class="memdesc:a521bf033d8d909ff180fc904988805cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the variable value. <br /></td></tr>
<tr class="separator:a521bf033d8d909ff180fc904988805cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2819447e55fdbe30c43726dd10ba9791"><td class="memTemplParams" colspan="2"><a id="a2819447e55fdbe30c43726dd10ba9791"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2819447e55fdbe30c43726dd10ba9791"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a2819447e55fdbe30c43726dd10ba9791">VariableHandle</a> = typename <a class="el" href="classRa_1_1Core_1_1VariableSet.html#a61f36df1dda66cf204afdec4c1e17d72">VariableContainer</a>&lt; T &gt;::iterator</td></tr>
<tr class="memdesc:a2819447e55fdbe30c43726dd10ba9791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle of a variable A handle on a variable with type T is an iterator into the BaseContainer. De-referencing the handle give access to a non const pair &lt;const std::string, T&gt; (BaseContainer&lt;T&gt;::value_type). VariableHandle validity follows the rules of BaseContainer&lt;T&gt;::iterator validity. <br /></td></tr>
<tr class="separator:a2819447e55fdbe30c43726dd10ba9791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3c960c4ae226d8cc6ec4a4fa093fee"><td class="memTemplParams" colspan="2">template&lt;typename H &gt; </td></tr>
<tr class="memitem:aff3c960c4ae226d8cc6ec4a4fa093fee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#aff3c960c4ae226d8cc6ec4a4fa093fee">VariableTypeFromHandle</a> = typename std::iterator_traits&lt; H &gt;::value_type::second_type</td></tr>
<tr class="memdesc:aff3c960c4ae226d8cc6ec4a4fa093fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the variable referenced by a VariableHandle.  <a href="classRa_1_1Core_1_1VariableSet.html#aff3c960c4ae226d8cc6ec4a4fa093fee">More...</a><br /></td></tr>
<tr class="separator:aff3c960c4ae226d8cc6ec4a4fa093fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af04d06c41883106db0647167c4471b53"><td class="memTemplParams" colspan="2"><a id="af04d06c41883106db0647167c4471b53"></a>
template&lt;typename F , typename U &gt; </td></tr>
<tr class="memitem:af04d06c41883106db0647167c4471b53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit</b> (F &amp;&amp;visitor, U &amp;userParams) const</td></tr>
<tr class="separator:af04d06c41883106db0647167c4471b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528e875cb8d6f35c463c265bfac73024"><td class="memTemplParams" colspan="2"><a id="a528e875cb8d6f35c463c265bfac73024"></a>
template&lt;typename F , typename U &gt; </td></tr>
<tr class="memitem:a528e875cb8d6f35c463c265bfac73024"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit</b> (F &amp;&amp;visitor, U &amp;&amp;userParams) const</td></tr>
<tr class="separator:a528e875cb8d6f35c463c265bfac73024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3b81b0c94834b4bba999b77ae29f832"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#aa3b81b0c94834b4bba999b77ae29f832">VariableSet</a> ()=default</td></tr>
<tr class="separator:aa3b81b0c94834b4bba999b77ae29f832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ce2e369e6181f40bae4c5c44c7aeb1"><td class="memItemLeft" align="right" valign="top"><a id="a12ce2e369e6181f40bae4c5c44c7aeb1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a12ce2e369e6181f40bae4c5c44c7aeb1">VariableSet</a> (const <a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;other)</td></tr>
<tr class="memdesc:a12ce2e369e6181f40bae4c5c44c7aeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> is copyable. <br /></td></tr>
<tr class="separator:a12ce2e369e6181f40bae4c5c44c7aeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8097400ca350df83ac01eea3b9ef80e1"><td class="memItemLeft" align="right" valign="top"><a id="a8097400ca350df83ac01eea3b9ef80e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a8097400ca350df83ac01eea3b9ef80e1">VariableSet</a> (<a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a8097400ca350df83ac01eea3b9ef80e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> is movable. <br /></td></tr>
<tr class="separator:a8097400ca350df83ac01eea3b9ef80e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aed95ce92bfe66c046a15875c42c90520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#aed95ce92bfe66c046a15875c42c90520">operator=</a> (const <a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;other)</td></tr>
<tr class="memdesc:aed95ce92bfe66c046a15875c42c90520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classRa_1_1Core_1_1VariableSet.html#aed95ce92bfe66c046a15875c42c90520">More...</a><br /></td></tr>
<tr class="separator:aed95ce92bfe66c046a15875c42c90520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95c3542dc7fff2c029f72e2df23d3ec"><td class="memItemLeft" align="right" valign="top"><a id="ab95c3542dc7fff2c029f72e2df23d3ec"></a>
<a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#ab95c3542dc7fff2c029f72e2df23d3ec">operator=</a> (<a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ab95c3542dc7fff2c029f72e2df23d3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:ab95c3542dc7fff2c029f72e2df23d3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54e3ea45c874bb1d3f7c36c63d93034"><td class="memItemLeft" align="right" valign="top"><a id="aa54e3ea45c874bb1d3f7c36c63d93034"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#aa54e3ea45c874bb1d3f7c36c63d93034">clear</a> ()</td></tr>
<tr class="memdesc:aa54e3ea45c874bb1d3f7c36c63d93034"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all elements from the container <br /></td></tr>
<tr class="separator:aa54e3ea45c874bb1d3f7c36c63d93034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8632a526adf0342cd1f7407626b536d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a8632a526adf0342cd1f7407626b536d2">mergeKeepVariables</a> (const <a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;from)</td></tr>
<tr class="memdesc:a8632a526adf0342cd1f7407626b536d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> <b>from</b> into this.  <a href="classRa_1_1Core_1_1VariableSet.html#a8632a526adf0342cd1f7407626b536d2">More...</a><br /></td></tr>
<tr class="separator:a8632a526adf0342cd1f7407626b536d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b16edce3a38198144e923974c401e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#ab2b16edce3a38198144e923974c401e6">mergeReplaceVariables</a> (const <a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;from)</td></tr>
<tr class="memdesc:ab2b16edce3a38198144e923974c401e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> <b>from</b> into this.  <a href="classRa_1_1Core_1_1VariableSet.html#ab2b16edce3a38198144e923974c401e6">More...</a><br /></td></tr>
<tr class="separator:ab2b16edce3a38198144e923974c401e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61f787c8d6590c5bb6dbbf9dd617ef4"><td class="memItemLeft" align="right" valign="top"><a id="ab61f787c8d6590c5bb6dbbf9dd617ef4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#ab61f787c8d6590c5bb6dbbf9dd617ef4">size</a> () const</td></tr>
<tr class="memdesc:ab61f787c8d6590c5bb6dbbf9dd617ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of variables (of any type) <br /></td></tr>
<tr class="separator:ab61f787c8d6590c5bb6dbbf9dd617ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fdbc8a5f7f2972b075112babcd2737"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::type_index &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a85fdbc8a5f7f2972b075112babcd2737">getStoredTypes</a> () const</td></tr>
<tr class="memdesc:a85fdbc8a5f7f2972b075112babcd2737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stored data type.  <a href="classRa_1_1Core_1_1VariableSet.html#a85fdbc8a5f7f2972b075112babcd2737">More...</a><br /></td></tr>
<tr class="separator:a85fdbc8a5f7f2972b075112babcd2737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5cd78b363ba77491b96337096b923529"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cd78b363ba77491b96337096b923529"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classRa_1_1Core_1_1VariableSet.html#a2819447e55fdbe30c43726dd10ba9791">VariableHandle</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a5cd78b363ba77491b96337096b923529">insertVariable</a> (const std::string &amp;name, const T &amp;value)</td></tr>
<tr class="memdesc:a5cd78b363ba77491b96337096b923529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a variable, i.e. an association name-&gt;value, into the container.  <a href="classRa_1_1Core_1_1VariableSet.html#a5cd78b363ba77491b96337096b923529">More...</a><br /></td></tr>
<tr class="separator:a5cd78b363ba77491b96337096b923529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac820cfb97bcdea47e4a9025a691d0df6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac820cfb97bcdea47e4a9025a691d0df6"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#ac820cfb97bcdea47e4a9025a691d0df6">getVariable</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ac820cfb97bcdea47e4a9025a691d0df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of the given variable  <a href="classRa_1_1Core_1_1VariableSet.html#ac820cfb97bcdea47e4a9025a691d0df6">More...</a><br /></td></tr>
<tr class="separator:ac820cfb97bcdea47e4a9025a691d0df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadb28dcebd2d96c593062ddeb17b675"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeadb28dcebd2d96c593062ddeb17b675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a2819447e55fdbe30c43726dd10ba9791">VariableHandle</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#aeadb28dcebd2d96c593062ddeb17b675">getVariableHandle</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:aeadb28dcebd2d96c593062ddeb17b675"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the handle on the variable with the given name  <a href="classRa_1_1Core_1_1VariableSet.html#aeadb28dcebd2d96c593062ddeb17b675">More...</a><br /></td></tr>
<tr class="separator:aeadb28dcebd2d96c593062ddeb17b675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae681263d3319088935f1ca8c0cef93"><td class="memTemplParams" colspan="2">template&lt;typename H &gt; </td></tr>
<tr class="memitem:a2ae681263d3319088935f1ca8c0cef93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a2ae681263d3319088935f1ca8c0cef93">isHandleValid</a> (const H &amp;handle) const</td></tr>
<tr class="memdesc:a2ae681263d3319088935f1ca8c0cef93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the validity of a handle.  <a href="classRa_1_1Core_1_1VariableSet.html#a2ae681263d3319088935f1ca8c0cef93">More...</a><br /></td></tr>
<tr class="separator:a2ae681263d3319088935f1ca8c0cef93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72472189a29f1656ff0603c1e0db1786"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72472189a29f1656ff0603c1e0db1786"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classRa_1_1Core_1_1VariableSet.html#a2819447e55fdbe30c43726dd10ba9791">VariableHandle</a>&lt; T &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a72472189a29f1656ff0603c1e0db1786">insertOrAssignVariable</a> (const std::string &amp;name, const T &amp;value)</td></tr>
<tr class="memdesc:a72472189a29f1656ff0603c1e0db1786"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset (or set if the variable does not exist yet) the value of the variable.  <a href="classRa_1_1Core_1_1VariableSet.html#a72472189a29f1656ff0603c1e0db1786">More...</a><br /></td></tr>
<tr class="separator:a72472189a29f1656ff0603c1e0db1786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3fe97fce185a5bce5f2a5e2cf799a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f3fe97fce185a5bce5f2a5e2cf799a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a4f3fe97fce185a5bce5f2a5e2cf799a6">deleteVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a4f3fe97fce185a5bce5f2a5e2cf799a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a variable, i.e. a name-&gt;value association.  <a href="classRa_1_1Core_1_1VariableSet.html#a4f3fe97fce185a5bce5f2a5e2cf799a6">More...</a><br /></td></tr>
<tr class="separator:a4f3fe97fce185a5bce5f2a5e2cf799a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bd8863865a8adbce90f1838e0bad0c"><td class="memTemplParams" colspan="2">template&lt;typename H &gt; </td></tr>
<tr class="memitem:a06bd8863865a8adbce90f1838e0bad0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a06bd8863865a8adbce90f1838e0bad0c">deleteVariable</a> (H &amp;handle)</td></tr>
<tr class="memdesc:a06bd8863865a8adbce90f1838e0bad0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete a variable from its handle  <a href="classRa_1_1Core_1_1VariableSet.html#a06bd8863865a8adbce90f1838e0bad0c">More...</a><br /></td></tr>
<tr class="separator:a06bd8863865a8adbce90f1838e0bad0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e3584e49b57fb22076cf4c9472aec7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90e3584e49b57fb22076cf4c9472aec7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a90e3584e49b57fb22076cf4c9472aec7">existsVariable</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a90e3584e49b57fb22076cf4c9472aec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">test the existence of the given variable  <a href="classRa_1_1Core_1_1VariableSet.html#a90e3584e49b57fb22076cf4c9472aec7">More...</a><br /></td></tr>
<tr class="separator:a90e3584e49b57fb22076cf4c9472aec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3c77f3b54588b9fb9ecb25409be76d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3c77f3b54588b9fb9ecb25409be76d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#ab3c77f3b54588b9fb9ecb25409be76d5">existsVariableType</a> () const</td></tr>
<tr class="memdesc:ab3c77f3b54588b9fb9ecb25409be76d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the storage supports a given variable type.  <a href="classRa_1_1Core_1_1VariableSet.html#ab3c77f3b54588b9fb9ecb25409be76d5">More...</a><br /></td></tr>
<tr class="separator:ab3c77f3b54588b9fb9ecb25409be76d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d10586d65743976c50ecd5c1e759ea1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d10586d65743976c50ecd5c1e759ea1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a3d10586d65743976c50ecd5c1e759ea1">deleteAllVariables</a> ()</td></tr>
<tr class="memdesc:a3d10586d65743976c50ecd5c1e759ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all variables of the given type.  <a href="classRa_1_1Core_1_1VariableSet.html#a3d10586d65743976c50ecd5c1e759ea1">More...</a><br /></td></tr>
<tr class="separator:a3d10586d65743976c50ecd5c1e759ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7706a65c9d49e4d894ac50d66c4db3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e7706a65c9d49e4d894ac50d66c4db3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a61f36df1dda66cf204afdec4c1e17d72">VariableContainer</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a4e7706a65c9d49e4d894ac50d66c4db3">getAllVariables</a> () const</td></tr>
<tr class="memdesc:a4e7706a65c9d49e4d894ac50d66c4db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the whole container for variables of a given type.  <a href="classRa_1_1Core_1_1VariableSet.html#a4e7706a65c9d49e4d894ac50d66c4db3">More...</a><br /></td></tr>
<tr class="separator:a4e7706a65c9d49e4d894ac50d66c4db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d3b97c47fe66792ff2d5a6658dbc59"><td class="memTemplParams" colspan="2">template&lt;typename H &gt; </td></tr>
<tr class="memitem:a89d3b97c47fe66792ff2d5a6658dbc59"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a89d3b97c47fe66792ff2d5a6658dbc59">getAllVariablesFromHandle</a> (const H &amp;handle) -&gt; <a class="el" href="classRa_1_1Core_1_1VariableSet.html#a61f36df1dda66cf204afdec4c1e17d72">VariableContainer</a>&lt; <a class="el" href="classRa_1_1Core_1_1VariableSet.html#aff3c960c4ae226d8cc6ec4a4fa093fee">VariableTypeFromHandle</a>&lt; H &gt;&gt; &amp;</td></tr>
<tr class="memdesc:a89d3b97c47fe66792ff2d5a6658dbc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the whole container for variables of the same type than the given handled variable.  <a href="classRa_1_1Core_1_1VariableSet.html#a89d3b97c47fe66792ff2d5a6658dbc59">More...</a><br /></td></tr>
<tr class="separator:a89d3b97c47fe66792ff2d5a6658dbc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b07cfdaf8bbcd2c720f65d052ff10d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73b07cfdaf8bbcd2c720f65d052ff10d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a73b07cfdaf8bbcd2c720f65d052ff10d">numberOf</a> () const</td></tr>
<tr class="memdesc:a73b07cfdaf8bbcd2c720f65d052ff10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of variables of the given type.  <a href="classRa_1_1Core_1_1VariableSet.html#a73b07cfdaf8bbcd2c720f65d052ff10d">More...</a><br /></td></tr>
<tr class="separator:a73b07cfdaf8bbcd2c720f65d052ff10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1822f08e78f9d4d63feebfcf05a710f1"><td class="memTemplParams" colspan="2">template&lt;typename P  = bool&gt; </td></tr>
<tr class="memitem:a1822f08e78f9d4d63feebfcf05a710f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a1822f08e78f9d4d63feebfcf05a710f1">visitDynamic</a> (<a class="el" href="classRa_1_1Core_1_1VariableSet_1_1DynamicVisitorBase.html">DynamicVisitorBase</a> &amp;visitor, P &amp;&amp;params=P {}) const</td></tr>
<tr class="memdesc:a1822f08e78f9d4d63feebfcf05a710f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit the container using a dynamically typed visitor.  <a href="classRa_1_1Core_1_1VariableSet.html#a1822f08e78f9d4d63feebfcf05a710f1">More...</a><br /></td></tr>
<tr class="separator:a1822f08e78f9d4d63feebfcf05a710f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff01d871519d7cd33380f6f8bf1899d"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:abff01d871519d7cd33380f6f8bf1899d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#abff01d871519d7cd33380f6f8bf1899d">visit</a> (F &amp;&amp;visitor) const</td></tr>
<tr class="memdesc:abff01d871519d7cd33380f6f8bf1899d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit the container using a statically typed visitor.  <a href="classRa_1_1Core_1_1VariableSet.html#abff01d871519d7cd33380f6f8bf1899d">More...</a><br /></td></tr>
<tr class="separator:abff01d871519d7cd33380f6f8bf1899d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f13d062e1be33a898983f87ec130bc"><td class="memTemplParams" colspan="2"><a id="a41f13d062e1be33a898983f87ec130bc"></a>
template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a41f13d062e1be33a898983f87ec130bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a41f13d062e1be33a898983f87ec130bc">visit</a> (F &amp;&amp;visitor, T &amp;userParams) const</td></tr>
<tr class="memdesc:a41f13d062e1be33a898983f87ec130bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload of the static visit method to allow a parameter pass by reference <br /></td></tr>
<tr class="separator:a41f13d062e1be33a898983f87ec130bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ac599636f331aaf2b67257dbd3291c"><td class="memTemplParams" colspan="2"><a id="a16ac599636f331aaf2b67257dbd3291c"></a>
template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a16ac599636f331aaf2b67257dbd3291c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a16ac599636f331aaf2b67257dbd3291c">visit</a> (F &amp;&amp;visitor, T &amp;&amp;userParams) const</td></tr>
<tr class="memdesc:a16ac599636f331aaf2b67257dbd3291c"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload of the static visit method to allow a parameter pass by rvalue reference <br /></td></tr>
<tr class="separator:a16ac599636f331aaf2b67257dbd3291c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Heterogeneous container storing "Variables", that maps a name (std::string) to a value (of any type T). </p>
<p>The container is compatible with any type, from simple arithmetic type to wrapped references to any other type.</p>
<p>"Variables" can be added, accessed and removed from the container given their type, name and value.</p>
<p>Given a type, the container gives access to the mapping name-&gt;value for all variables with the given type.</p>
<p>Stored variables can be referenced using a VariableHandle returned when a variable is inserted in the container or fetch giving the type and the name of the variable. Validity of the variable handle follows the same rules than the std::iterator attached to the underlying mapping storage (std::map&lt;std::string, T&gt;::iterator for the actual implementation).</p>
<p>From a variable handle (possibly invalid), the mapping name-&gt;value for all variables with the same type can be fetched. This allows generic, type agnostic, usage of the container as soon as a variable handle (even invalid) is available.</p>
<p>The container could be visited to apply processing, transformation, ... on all or part of the variables. The accept functions of the visitor are defined by the availability of a callable object whose profile is compatible with the visited types.</p>
<p>Visiting the container can be made</p><ul>
<li>using a statically typed visitor : accepted types are defined at compile time, as template parameters, and the visit is pre-processed by the compiler.</li>
<li>using a dynamically configurable visitor where functor accepting types can be added/removed at runtime. This kind of visit is a little more expensive while being more configurable. Tests using empty processing (to evaluate only the cost of visiting the collection) on different types showed a visit from 5 to 8 times slower. This penalty becomes quite low as soon as the processing during the visit is more complex</li>
</ul>
<p>The visiting of the collection can accept one user parameter to forward to each visit function. This parameter could be of any type, knowing the same parameter will be forwarded to all processing method when visiting a variable. Some constraints on user provided parameter depends on the visiting strategy</p><ul>
<li>For static visitors, this parameter is strongly typed and ALL the visiting function should be called with the profile void(const std::string&amp;, [const]T[&amp;], [const]U&amp;&amp;), for any variable type T and the user parameter type U.</li>
<li>For dynamic visitors, as they rely on type erasure pattern, the user parameter should be of any type U but this type is erased when calling the visiting function. So, visiting functions must be callable with the profile void(const std::string&amp;, [const]T[&amp;], [const]std::anyU&amp;&amp;) knowing that the std::any contains a parameter of type U.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>relies on C++ standard libraries extensions, version 2 or recommended implementation on compilers that do not provide this extension <a href="https://en.cppreference.com/w/cpp/experimental/lib_extensions_2">https://en.cppreference.com/w/cpp/experimental/lib_extensions_2</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> unit test source code for examples of usage of this container </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00067">67</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aff3c960c4ae226d8cc6ec4a4fa093fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3c960c4ae226d8cc6ec4a4fa093fee">&#9670;&nbsp;</a></span>VariableTypeFromHandle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRa_1_1Core_1_1VariableSet.html#aff3c960c4ae226d8cc6ec4a4fa093fee">Ra::Core::VariableSet::VariableTypeFromHandle</a> =  typename std::iterator_traits&lt;H&gt;::value_type::second_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the variable referenced by a VariableHandle. </p>
<dl class="section note"><dt>Note</dt><dd>This is the same as the one denoted by the type T in VariableHandle&lt;T&gt; or in VariableType&lt;T&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00094">94</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa3b81b0c94834b4bba999b77ae29f832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b81b0c94834b4bba999b77ae29f832">&#9670;&nbsp;</a></span>VariableSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ra::Core::VariableSet::VariableSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructors, destructors </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3d10586d65743976c50ecd5c1e759ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d10586d65743976c50ecd5c1e759ea1">&#9670;&nbsp;</a></span>deleteAllVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Ra::Core::VariableSet::deleteAllVariables</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all variables of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of variable to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the type is deleted, false if it was not managed before the call. Unregister all the functions associated with the type and remove the storage of existing variables. If several variables are still stored, they will be destroyed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00638">638</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="a4f3fe97fce185a5bce5f2a5e2cf799a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3fe97fce185a5bce5f2a5e2cf799a6">&#9670;&nbsp;</a></span>deleteVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Ra::Core::VariableSet::deleteVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a variable, i.e. a name-&gt;value association. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the variable was removed, false if </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The element <b>name</b> must exists with type <b>T</b>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00544">544</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="a06bd8863865a8adbce90f1838e0bad0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bd8863865a8adbce90f1838e0bad0c">&#9670;&nbsp;</a></span>deleteVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Ra::Core::VariableSet::deleteVariable </td>
          <td>(</td>
          <td class="paramtype">H &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delete a variable from its handle </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">H</td><td>Type of the handle. Expected to be VariableHandle&lt;T&gt; for some variable type T </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>the variable handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true variable was removed, false if not. If the variable was removed, handle is invalidated </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the handle must be valid </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00555">555</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classRa_1_1Core_1_1VariableSet_a06bd8863865a8adbce90f1838e0bad0c_cgraph.svg" width="376" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a90e3584e49b57fb22076cf4c9472aec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e3584e49b57fb22076cf4c9472aec7">&#9670;&nbsp;</a></span>existsVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Ra::Core::VariableSet::existsVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>test the existence of the given variable </p>
<dl class="section return"><dt>Returns</dt><dd>true if a variable with the given name and type exists in the storage, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00564">564</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="ab3c77f3b54588b9fb9ecb25409be76d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c77f3b54588b9fb9ecb25409be76d5">&#9670;&nbsp;</a></span>existsVariableType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Ra::Core::VariableSet::existsVariableType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the storage supports a given variable type. </p>
<p>Operators acting on a per type basis</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of variable to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the type is managed by the storage </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00632">632</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="a4e7706a65c9d49e4d894ac50d66c4db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7706a65c9d49e4d894ac50d66c4db3">&#9670;&nbsp;</a></span>getAllVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a61f36df1dda66cf204afdec4c1e17d72">VariableSet::VariableContainer</a>&lt; T &gt; &amp; Ra::Core::VariableSet::getAllVariables</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the whole container for variables of a given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The variable type to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the storage of the mapping name-&gt;value for the given type. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classRa_1_1Core_1_1VariableSet.html#ab3c77f3b54588b9fb9ecb25409be76d5" title="Test if the storage supports a given variable type.">existsVariableType&lt;T&gt;()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00659">659</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="a89d3b97c47fe66792ff2d5a6658dbc59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d3b97c47fe66792ff2d5a6658dbc59">&#9670;&nbsp;</a></span>getAllVariablesFromHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Ra::Core::VariableSet::getAllVariablesFromHandle </td>
          <td>(</td>
          <td class="paramtype">const H &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classRa_1_1Core_1_1VariableSet.html#a61f36df1dda66cf204afdec4c1e17d72">VariableContainer</a>&lt;<a class="el" href="classRa_1_1Core_1_1VariableSet.html#aff3c960c4ae226d8cc6ec4a4fa093fee">VariableTypeFromHandle</a>&lt;H&gt;&gt;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the whole container for variables of the same type than the given handled variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">H</td><td>Type of the variable handle, should be VariableHandle&lt;T&gt; for some type T </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>the handle to an existing variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the storage of the mapping name-&gt;value for the given type. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>existsVariableType&lt;HandledType&lt;H&gt;&gt;() variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00666">666</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="a85fdbc8a5f7f2972b075112babcd2737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fdbc8a5f7f2972b075112babcd2737">&#9670;&nbsp;</a></span>getStoredTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::type_index&gt;&amp; Ra::Core::VariableSet::getStoredTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the stored data type. </p>
<dl class="section return"><dt>Returns</dt><dd>constant vector of type_index </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00174">174</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="ac820cfb97bcdea47e4a9025a691d0df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac820cfb97bcdea47e4a9025a691d0df6">&#9670;&nbsp;</a></span>getVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; Ra::Core::VariableSet::getVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the value of the given variable </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The element <b>name</b> must exists with type <b>T</b>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00513">513</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="aeadb28dcebd2d96c593062ddeb17b675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadb28dcebd2d96c593062ddeb17b675">&#9670;&nbsp;</a></span>getVariableHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a2819447e55fdbe30c43726dd10ba9791">VariableSet::VariableHandle</a>&lt; T &gt; Ra::Core::VariableSet::getVariableHandle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the handle on the variable with the given name </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which can be de-referenced to obtain a std::pair&lt;const std::string, T&gt; representing the name and the value of the variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00520">520</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="a72472189a29f1656ff0603c1e0db1786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72472189a29f1656ff0603c1e0db1786">&#9670;&nbsp;</a></span>insertOrAssignVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classRa_1_1Core_1_1VariableSet.html#a2819447e55fdbe30c43726dd10ba9791">VariableSet::VariableHandle</a>&lt; T &gt;, bool &gt; Ra::Core::VariableSet::insertOrAssignVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reset (or set if the variable does not exist yet) the value of the variable. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the value was reset, false it was set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00537">537</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="a5cd78b363ba77491b96337096b923529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd78b363ba77491b96337096b923529">&#9670;&nbsp;</a></span>insertVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classRa_1_1Core_1_1VariableSet.html#a2819447e55fdbe30c43726dd10ba9791">VariableSet::VariableHandle</a>&lt; T &gt;, bool &gt; Ra::Core::VariableSet::insertVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a variable, i.e. an association name-&gt;value, into the container. </p>
<p>Operators acting on a per variable basis</p>
<dl class="section return"><dt>Returns</dt><dd>true if the variable is inserted, false if the name was already associated with another value (of the same type). In this case, keep the old value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00504">504</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="a2ae681263d3319088935f1ca8c0cef93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae681263d3319088935f1ca8c0cef93">&#9670;&nbsp;</a></span>isHandleValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Ra::Core::VariableSet::isHandleValid </td>
          <td>(</td>
          <td class="paramtype">const H &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the validity of a handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">H</td><td>Type of the handle. Expected to be VariableHandle&lt;T&gt; for some variable type T </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>the variable handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the handle is valid, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00527">527</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="a8632a526adf0342cd1f7407626b536d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8632a526adf0342cd1f7407626b536d2">&#9670;&nbsp;</a></span>mergeKeepVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ra::Core::VariableSet::mergeKeepVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge the <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> <b>from</b> into this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> to merge with the current. Existing variable into this, with same name as in from, are kept unchanged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRa_1_1Core_1_1VariableSet.html#ab2b16edce3a38198144e923974c401e6" title="Merge the VariableSet from into this.">mergeReplaceVariables</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8cpp_source.html#l00058">58</a> of file <a class="el" href="VariableSet_8cpp_source.html">VariableSet.cpp</a>.</p>

</div>
</div>
<a id="ab2b16edce3a38198144e923974c401e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b16edce3a38198144e923974c401e6">&#9670;&nbsp;</a></span>mergeReplaceVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ra::Core::VariableSet::mergeReplaceVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge the <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> <b>from</b> into this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> to merge with the current. Existing variable into this, with same name as in from, are replaced by from's one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRa_1_1Core_1_1VariableSet.html#a8632a526adf0342cd1f7407626b536d2" title="Merge the VariableSet from into this.">mergeKeepVariables</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8cpp_source.html#l00064">64</a> of file <a class="el" href="VariableSet_8cpp_source.html">VariableSet.cpp</a>.</p>

</div>
</div>
<a id="a73b07cfdaf8bbcd2c720f65d052ff10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b07cfdaf8bbcd2c720f65d052ff10d">&#9670;&nbsp;</a></span>numberOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Ra::Core::VariableSet::numberOf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of variables of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of variables with type T stored in the container </dd></dl>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00673">673</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="aed95ce92bfe66c046a15875c42c90520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed95ce92bfe66c046a15875c42c90520">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp; Ra::Core::VariableSet::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Operators acting on a the whole <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> </p>

<p class="definition">Definition at line <a class="el" href="VariableSet_8cpp_source.html#l00012">12</a> of file <a class="el" href="VariableSet_8cpp_source.html">VariableSet.cpp</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classRa_1_1Core_1_1VariableSet_aed95ce92bfe66c046a15875c42c90520_cgraph.svg" width="376" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abff01d871519d7cd33380f6f8bf1899d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff01d871519d7cd33380f6f8bf1899d">&#9670;&nbsp;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Ra::Core::VariableSet::visit </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit the container using a statically typed visitor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the visitor to use (see below) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The visitor object to use</td></tr>
  </table>
  </dd>
</dl>
<p>This visiting method is well adapted when the visited types are known at compile time. In this case, part of the visit logic is done at compile time by unfolding the call of the type-related visitors instead of looping over all the stored type. This visiting strategy loops on visited types at compile time (loop unrolled) then on each stored values at running time. So, this visiting strategy is more efficient than the dynamic one if visited types are always the same.</p>
<p>The type of the visiting functor F should be</p><ul>
<li>either derived from VariableSet::StaticVisitor&lt;Type1, Type2, ...&gt; with function operators with profile const operator(const std::string&amp; name, T&amp; value) available for all the requested types Type1, Type2, ...</li>
<li>either a user define class exposing a type list to unfold F::types (see <a class="el" href="structRa_1_1Core_1_1VariableSet_1_1TypeList.html" title="CRTP based Type list for statically typed visitors.">VariableSet::TypeList</a> and <a class="el" href="structRa_1_1Core_1_1VariableSet_1_1StaticVisitor.html" title="Base class for visitors with static supported types. Visiting will be prepared at compile time by unf...">VariableSet::StaticVisitor</a>) </li>
</ul>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00688">688</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<a id="a1822f08e78f9d4d63feebfcf05a710f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1822f08e78f9d4d63feebfcf05a710f1">&#9670;&nbsp;</a></span>visitDynamic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Ra::Core::VariableSet::visitDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRa_1_1Core_1_1VariableSet_1_1DynamicVisitorBase.html">DynamicVisitorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code>P&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit the container using a dynamically typed visitor. </p>
<p>Visiting operators </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The type of the parameter to pass to visitor operators (see below) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The visitor to use </td></tr>
    <tr><td class="paramname">params</td><td>optional parameter to forward to visitor functor</td></tr>
  </table>
  </dd>
</dl>
<p>This visiting method is adapted when the types to visit are only known at running time. At running time, this visiting approach relies on two loops.</p><ul>
<li>The first loop, done by the visiting logic in the class <a class="el" href="classRa_1_1Core_1_1VariableSet.html" title="Heterogeneous container storing &quot;Variables&quot;, that maps a name (std::string) to a value (of any type T...">VariableSet</a> iterate over the types stored for the mappings name-&gt;value to identify the accepted types by the visitor.</li>
<li>The second loop, done by the visiting logic for accepted types, loop over name-&gt;value mappings and call the visitor functor for each pair</li>
</ul>
<p>The type of the visiting functor F should be</p><ul>
<li>either derived from <a class="el" href="classRa_1_1Core_1_1VariableSet_1_1DynamicVisitor.html" title="Base class for visitors with configurable per-type callbacks. Visiting will be prepared at running ti...">VariableSet::DynamicVisitor</a> with the needed visiting operators registered (<dl class="section see"><dt>See also</dt><dd>see <a class="el" href="classRa_1_1Core_1_1VariableSet_1_1DynamicVisitor.html" title="Base class for visitors with configurable per-type callbacks. Visiting will be prepared at running ti...">VariableSet::DynamicVisitor</a>)</dd></dl>
</li>
<li>either derived directly from <a class="el" href="classRa_1_1Core_1_1VariableSet_1_1DynamicVisitorBase.html" title="Base class for dynamically configurable visitors Users can implement this interface to build custom v...">DynamicVisitorBase</a> to build a full custom visitor. In this case, the first given std::any rvalue reference wraps a reference to a std::pair&lt;const std::string, T&gt; such that the first element of the pair is the name of the variable, and the second its value of type T. The second std::any&amp;&amp; rvalue reference contains an optional parameter to pass to the visiting functors (the same for all types) if the accept to be called with such a parameter. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="VariableSet_8hpp_source.html#l00680">680</a> of file <a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/Radium-Engine/Radium-Engine/src/Radium-Engine/src/Core/Containers/<a class="el" href="VariableSet_8hpp_source.html">VariableSet.hpp</a></li>
<li>/home/runner/work/Radium-Engine/Radium-Engine/src/Radium-Engine/src/Core/Containers/<a class="el" href="VariableSet_8cpp_source.html">VariableSet.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceRa.html">Ra</a></li><li class="navelem"><b>Core</b></li><li class="navelem"><a class="el" href="classRa_1_1Core_1_1VariableSet.html">VariableSet</a></li>
    <li class="footer">Generated on Thu Feb 9 2023 15:47:10 for Radium Engine by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
